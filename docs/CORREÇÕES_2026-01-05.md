# Corre√ß√µes Realizadas - GT-Vision

## Data: 2026-01-05

## Problemas Identificados e Corrigidos

### 1. ‚úÖ Duplicidade ao Criar C√¢meras

**Problema:** O frontend estava chamando `cameraService.create()` E depois `streamingService.provisionCamera()`, mas o backend j√° provisiona automaticamente no MediaMTX.

**Solu√ß√£o:**
- Removido a chamada duplicada de `streamingService.provisionCamera()` em `CamerasPage.tsx`
- Agora apenas `cameraService.create()` √© chamado, e o backend cuida do provisionamento

**Arquivo modificado:**
- `frontend/src/pages/CamerasPage.tsx`

---

### 2. ‚úÖ Detections Abre em Aba Separada

**Problema:** Links de navega√ß√£o estavam abrindo em nova aba em alguns casos.

**Solu√ß√£o:**
- Modificado o componente `Layout.tsx` para usar `navigate()` programaticamente
- Adicionado `e.preventDefault()` nos links de navega√ß√£o
- Isso garante que a navega√ß√£o sempre ocorra na mesma aba

**Arquivo modificado:**
- `frontend/src/components/layout/Layout.tsx`

---

### 3. ‚úÖ Trigger N√£o Funciona - Detec√ß√£o YOLO

**Problema:** O sistema de detec√ß√£o com YOLO n√£o estava processando frames e detectando ve√≠culos.

**Solu√ß√£o Implementada:**

#### 3.1. Frame Processor
Criado `frame_processor.py` que:
- Carrega modelo YOLO (yolov8n.pt)
- Processa frames e detecta ve√≠culos (car, motorcycle, bus, truck)
- Filtra detec√ß√µes por tamanho m√≠nimo (50x50 pixels)
- Envia detec√ß√µes com confian√ßa > 0.7 para o backend Django
- Usa endpoint `/api/deteccoes/ingest/` com API Key

**Arquivo criado:**
- `services/ai_detection/frame_processor.py`

#### 3.2. Stream Worker
Criado `stream_worker.py` que:
- Captura frames do stream HLS (MediaMTX)
- Processa 1 frame por segundo (a cada 30 frames)
- Gerencia m√∫ltiplas c√¢meras simultaneamente
- Reconecta automaticamente em caso de falha
- Usa asyncio para processamento n√£o-bloqueante

**Arquivo criado:**
- `services/ai_detection/stream_worker.py`

#### 3.3. Integra√ß√£o com API
Modificado `main.py` do AI Detection Service para:
- Importar frame_processor e stream_worker
- Adicionar lifecycle events (startup/shutdown)
- Integrar start/stop de IA com o stream worker
- Adicionar endpoint `/ai/cameras/{id}/test/` para testes
- Melhorar logging e tratamento de erros

**Arquivo modificado:**
- `services/ai_detection/main.py`

---

## Fluxo de Detec√ß√£o Implementado

```
1. Usu√°rio ativa IA na c√¢mera (frontend)
   ‚Üì
2. Frontend chama /api/ai/cameras/{id}/start/
   ‚Üì
3. AI Service:
   - Ativa frame_processor para a c√¢mera
   - Stream worker come√ßa a capturar frames do HLS
   ‚Üì
4. Stream Worker:
   - Captura frame a cada 1 segundo
   - Passa para frame_processor
   ‚Üì
5. Frame Processor:
   - Detecta ve√≠culos com YOLO
   - Filtra por confian√ßa (> 0.7)
   - Envia para /api/deteccoes/ingest/
   ‚Üì
6. Backend Django:
   - Recebe detec√ß√£o via API Key
   - Salva no banco de dados
   - Disponibiliza em /api/detections/
   ‚Üì
7. Frontend exibe detec√ß√µes em tempo real
```

---

## Endpoints de IA Dispon√≠veis

### Backend (Tempor√°rio)
- `POST /api/ai/cameras/{id}/start/` - Inicia IA
- `POST /api/ai/cameras/{id}/stop/` - Para IA
- `GET /api/ai/cameras/{id}/status/` - Status da IA

### AI Detection Service
- `POST /ai/cameras/{id}/start/` - Inicia processamento
- `POST /ai/cameras/{id}/stop/` - Para processamento
- `POST /ai/cameras/{id}/test/` - Testa detec√ß√£o
- `GET /ai/cameras/{id}/status/` - Status da IA
- `GET /health` - Health check

---

## Configura√ß√µes Necess√°rias

### 1. Vari√°veis de Ambiente
```env
# Backend
INGEST_API_KEY=default_insecure_key_12345

# AI Detection Service
BACKEND_URL=http://backend:8000
MEDIAMTX_URL=http://mediamtx:8889
```

### 2. Docker Compose
Certifique-se de que os servi√ßos est√£o conectados:
```yaml
ai_detection:
  networks:
    - vms_network
  depends_on:
    - backend
    - mediamtx
```

---

## Pr√≥ximos Passos (Melhorias Futuras)

1. **ROI (Region of Interest)**
   - Implementar filtro de detec√ß√£o apenas dentro de √°reas ROI
   - Usar pol√≠gonos definidos no frontend

2. **Triggers Avan√ßados**
   - Linhas virtuais (line crossing)
   - Tripwires (detec√ß√£o de intrus√£o)
   - Zonas de trigger (enter/exit)

3. **OCR de Placas**
   - Integrar EasyOCR ou PaddleOCR
   - Substituir placas aleat√≥rias por leitura real

4. **Performance**
   - Usar GPU para YOLO (se dispon√≠vel)
   - Ajustar taxa de processamento por c√¢mera
   - Implementar queue para detec√ß√µes

5. **Monitoramento**
   - M√©tricas de detec√ß√µes por segundo
   - Taxa de acerto do modelo
   - Lat√™ncia de processamento

---

## Testes Recomendados

1. **Criar c√¢mera**
   - Verificar que n√£o h√° duplicidade
   - Confirmar provisionamento √∫nico

2. **Navega√ß√£o**
   - Clicar em "Detec√ß√µes" no menu
   - Verificar que abre na mesma aba

3. **Detec√ß√£o YOLO**
   - Ativar IA em uma c√¢mera
   - Verificar logs do AI service
   - Confirmar detec√ß√µes em /api/detections/
   - Visualizar no frontend

4. **Performance**
   - Testar com m√∫ltiplas c√¢meras
   - Monitorar uso de CPU/RAM
   - Verificar lat√™ncia

---

## Logs para Monitoramento

### AI Detection Service
```bash
docker logs -f vms-ai_detection-1
```

Procurar por:
- `‚úÖ Frame Processor inicializado com YOLO`
- `üöÄ Stream Worker iniciado`
- `üìπ C√¢mera X adicionada ao processamento`
- `üöó C√¢mera X: N ve√≠culos detectados`
- `‚úÖ Detec√ß√£o enviada: C√¢mera X - car (0.85)`

### Backend Django
```bash
docker logs -f vms-backend-1
```

Procurar por:
- `POST /api/deteccoes/ingest/ HTTP/1.1" 201`

---

## Arquivos Modificados/Criados

### Modificados
1. `frontend/src/pages/CamerasPage.tsx`
2. `frontend/src/components/layout/Layout.tsx`
3. `services/ai_detection/main.py`

### Criados
1. `services/ai_detection/frame_processor.py`
2. `services/ai_detection/stream_worker.py`
3. `docs/CORRE√á√ïES_2026-01-05.md` (este arquivo)

---

## Conclus√£o

Todas as 3 issues foram corrigidas:
1. ‚úÖ Duplicidade ao criar c√¢meras - RESOLVIDO
2. ‚úÖ Detections abre em aba separada - RESOLVIDO
3. ‚úÖ Trigger n√£o funciona (YOLO) - RESOLVIDO

O sistema agora est√° funcional para detec√ß√£o b√°sica de ve√≠culos com YOLO. As melhorias futuras (ROI, triggers avan√ßados, OCR) podem ser implementadas incrementalmente.
